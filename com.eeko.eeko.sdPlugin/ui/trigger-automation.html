<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Eeko Automation Trigger Settings</title>
    <style>
/* Simplified Stream Deck Property Inspector Styles */
body {
    margin: 0;
    padding: 16px;
    background: linear-gradient(135deg, #2D2D30 0%, #1E1E21 100%);
    color: #D0D0D0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 13px;
}

.sdpi-wrapper {
    max-width: 340px;
    margin: 0 auto;
}

.sdpi-item {
    display: flex;
    flex-direction: column;
    margin-bottom: 20px;
}

.sdpi-item-label {
    color: #FFFFFF;
    font-size: 12px;
    font-weight: 600;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.8px;
}

.sdpi-item-value {
    background: linear-gradient(145deg, #3C3C3C 0%, #323234 100%);
    border: 1px solid #505052;
    border-radius: 6px;
    color: #E0E0E0;
    font-size: 13px;
    padding: 10px 12px;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    transition: all 0.2s ease;
}

.sdpi-item-value:focus {
    border-color: #0078D4;
    box-shadow: 0 0 0 3px rgba(0, 120, 212, 0.25);
    background: #404042;
}

.sdpi-item-value.loading {
    background-image: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    background-size: 200px 100%;
    animation: loading 1.5s infinite;
}

.sdpi-item-value.success {
    border-color: #4CAF50;
    box-shadow: 0 0 0 1px rgba(76, 175, 80, 0.3);
}

.sdpi-item-value.error {
    border-color: #F44336;
    box-shadow: 0 0 0 1px rgba(244, 67, 54, 0.3);
}

.validation-icon {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 16px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.validation-icon.show {
    opacity: 1;
}

.validation-icon.success {
    color: #4CAF50;
}

.validation-icon.error {
    color: #F44336;
}

.validation-icon.loading {
    color: #2196F3;
    animation: spin 1s linear infinite;
}

.field-container {
    position: relative;
}

.help-text {
    font-size: 11px;
    color: #999;
    margin-top: 6px;
    line-height: 1.3;
}

.help-text.error {
    color: #F44336;
}

@keyframes loading {
    0% { background-position: -200px 0; }
    100% { background-position: 200px 0; }
}

@keyframes spin {
    from { transform: translateY(-50%) rotate(0deg); }
    to { transform: translateY(-50%) rotate(360deg); }
}
    </style>
</head>
<body>
    <div class="sdpi-wrapper">
        <div class="sdpi-item">
            <div class="sdpi-item-label">ðŸ”‘ API Key</div>
            <div class="field-container">
                <input class="sdpi-item-value" id="apiKey" type="password" placeholder="eko_xxxxxxxxxxxx">
                <div class="validation-icon" id="apiKeyIcon">âœ“</div>
            </div>
            <div class="help-text" id="apiKeyHelp">Enter your Eeko API key (shared across all keys)</div>
        </div>

        <div class="sdpi-item">
            <div class="sdpi-item-label">âš¡ Automation</div>
            <div class="field-container">
                <select class="sdpi-item-value" id="automationSelect" disabled>
                    <option value="">Enter API key first</option>
                </select>
                <div class="validation-icon" id="automationIcon">âœ“</div>
            </div>
            <div class="help-text" id="automationHelp">Choose which automation to trigger</div>
        </div>
    </div>

    <script>
let globalSettings = {};
let globalApiKey = '';

// Stream Deck Property Inspector connection handler
function connectElgatoStreamDeckSocket(inPort, inUUID, inMessageType, inApplicationInfo, inActionInfo) {
    
    const websocket = new WebSocket('ws://127.0.0.1:' + inPort);
    
    websocket.onopen = function () {
        // Register with Stream Deck
        const json = {
            event: inMessageType,
            uuid: inUUID
        };
        websocket.send(JSON.stringify(json));

        // Load existing settings from initial payload
        if (inActionInfo?.payload?.settings) {
            globalSettings = inActionInfo.payload.settings;
            loadSettings();
        }

        // Request current API key from global settings
        const getApiKeyJson = {
            event: 'sendToPlugin',
            context: inActionInfo?.context || inUUID,
            payload: { action: 'getApiKey' }
        };
        websocket.send(JSON.stringify(getApiKeyJson));

        // Also request current settings to ensure we have the latest
        const getSettingsJson = {
            event: 'getSettings',
            context: inActionInfo?.context || inUUID
        };
        websocket.send(JSON.stringify(getSettingsJson));
    };

    // Add focus event listener to reload automations when window gains focus
    window.addEventListener('focus', function() {
        if (globalApiKey) {
            // Request fresh automations when window gains focus
            const fetchAutomationsJson = {
                event: 'sendToPlugin',
                context: inActionInfo?.context || inUUID,
                payload: { action: 'fetchAutomations', data: { apiKey: globalApiKey } }
            };
            websocket.send(JSON.stringify(fetchAutomationsJson));
        }
    });
    
    websocket.onmessage = function (evt) {
        const jsonObj = JSON.parse(evt.data);
        
        if (jsonObj.event === 'didReceiveSettings') {
            globalSettings = jsonObj.payload.settings;
            loadSettings();
        } else if (jsonObj.event === 'sendToPropertyInspector') {
            // Handle messages sent from the plugin
            const pluginMessage = jsonObj.payload;
            
            if (pluginMessage.event === 'apiKeyLoaded') {
                globalApiKey = pluginMessage.payload.apiKey;
                document.getElementById('apiKey').value = globalApiKey;
                if (globalApiKey) {
                    setApiKeyState('success', 'API key loaded (shared across keys)');

                    // Always load automations when API key is loaded
                    setApiKeyState('loading', 'Loading automations...');
                    const automationSelect = document.getElementById('automationSelect');
                    automationSelect.disabled = true;
                    automationSelect.innerHTML = '<option value="">Loading automations...</option>';

                    // Request automations for this API key
                    const fetchAutomationsJson = {
                        event: 'sendToPlugin',
                        context: inActionInfo?.context || inUUID,
                        payload: { action: 'fetchAutomations', data: { apiKey: globalApiKey } }
                    };
                    websocket.send(JSON.stringify(fetchAutomationsJson));
                }
            } else if (pluginMessage.event === 'automationsLoaded') {
                populateAutomationList(pluginMessage.payload.automations);
            } else if (pluginMessage.event === 'apiKeyError') {
                showError(pluginMessage.payload.error);
            }
        } else if (jsonObj.event === 'automationsLoaded') {
            // Direct message (legacy)
            populateAutomationList(jsonObj.payload.automations);
        } else if (jsonObj.event === 'apiKeyError') {
            // Direct message (legacy)
            showError(jsonObj.payload.error);
        }
    };
    
    // Set up event listeners for settings changes
    document.getElementById('apiKey').addEventListener('input', function() {
        const apiKey = this.value.trim();
        
        // Save API key to global settings and validate
        if (apiKey && apiKey !== globalApiKey) {
            // Validate API key format client-side
            if (apiKey.length < 10 || apiKey.length > 200 || !/^[a-zA-Z0-9_-]+$/.test(apiKey)) {
                setApiKeyState('error', 'Invalid API key format');
                return;
            }
            globalApiKey = apiKey;
            setApiKeyState('loading', 'Validating and saving API key...');
            const saveApiKeyJson = {
                event: 'sendToPlugin',
                context: inActionInfo?.context || inUUID,
                payload: { action: 'saveApiKey', data: { apiKey } }
            };
            websocket.send(JSON.stringify(saveApiKeyJson));
        }
        
        // Clear automation selection when API key changes
        if (apiKey) {
            const automationSelect = document.getElementById('automationSelect');
            automationSelect.disabled = true;
            automationSelect.innerHTML = '<option value="">Loading automations...</option>';
            
            // Clear previously selected automation
            saveSetting('automationId', '');
            saveSetting('automationName', '');
            setAutomationState('default');
        } else {
            setApiKeyState('default');
            const automationSelect = document.getElementById('automationSelect');
            automationSelect.disabled = true;
            automationSelect.innerHTML = '<option value="">Enter API key first</option>';
            setAutomationState('default');
        }
    });
    
    document.getElementById('automationSelect').addEventListener('change', function() {
        const automationId = this.value;
        saveSetting('automationId', automationId);
        
        const selectedOption = this.options[this.selectedIndex];
        if (selectedOption && automationId) {
            saveSetting('automationName', selectedOption.text);
            setAutomationState('success', 'Automation configured');
        } else {
            saveSetting('automationName', '');
            setAutomationState('default');
        }
    });
    
    function saveSetting(key, value) {
        globalSettings[key] = value;
        
        const json = {
            event: 'setSettings',
            context: inActionInfo?.context || inUUID,
            payload: globalSettings
        };
        websocket.send(JSON.stringify(json));
    }
}

function loadSettings() {
    const apiKeyInput = document.getElementById('apiKey');
    const automationSelect = document.getElementById('automationSelect');

    // API key comes from global settings, not local
    if (globalApiKey) {
        apiKeyInput.value = globalApiKey;
        setApiKeyState('success', 'API key loaded (shared across keys)');

        // Show the current selection temporarily while loading fresh list
        if (globalSettings.automationId && globalSettings.automationName) {
            automationSelect.innerHTML = `<option value="${globalSettings.automationId}" selected>${globalSettings.automationName}</option>`;
            automationSelect.disabled = false;
            setAutomationState('success', 'Configuration loaded');
        } else {
            automationSelect.innerHTML = '<option value="">Loading automations...</option>';
            automationSelect.disabled = true;
        }

        // Note: Automations will be loaded when we receive the apiKeyLoaded event
    } else {
        // No API key, show initial state
        setApiKeyState('default');
        automationSelect.innerHTML = '<option value="">Enter API key first</option>';
        automationSelect.disabled = true;
        setAutomationState('default');
    }
}

function setApiKeyState(state, message = '') {
    const input = document.getElementById('apiKey');
    const icon = document.getElementById('apiKeyIcon');
    const help = document.getElementById('apiKeyHelp');
    
    // Reset all states
    input.classList.remove('loading', 'success', 'error');
    icon.classList.remove('show', 'loading', 'success', 'error');
    help.classList.remove('error');
    
    switch(state) {
        case 'loading':
            input.classList.add('loading');
            icon.innerHTML = 'âŸ³';
            icon.classList.add('show', 'loading');
            help.textContent = message || 'Validating...';
            break;
        case 'success':
            input.classList.add('success');
            icon.innerHTML = 'âœ“';
            icon.classList.add('show', 'success');
            help.textContent = message || 'API key valid';
            break;
        case 'error':
            input.classList.add('error');
            icon.innerHTML = 'âœ—';
            icon.classList.add('show', 'error');
            help.textContent = message || 'Invalid API key';
            help.classList.add('error');
            break;
        default:
            help.textContent = 'Enter your Eeko API key to load automations';
    }
}

function setAutomationState(state, message = '') {
    const select = document.getElementById('automationSelect');
    const icon = document.getElementById('automationIcon');
    const help = document.getElementById('automationHelp');
    
    // Reset all states
    select.classList.remove('success', 'error');
    icon.classList.remove('show', 'success', 'error');
    help.classList.remove('error');
    
    switch(state) {
        case 'success':
            select.classList.add('success');
            icon.innerHTML = 'âœ“';
            icon.classList.add('show', 'success');
            help.textContent = message || 'Ready to trigger';
            break;
        case 'error':
            select.classList.add('error');
            icon.innerHTML = 'âœ—';
            icon.classList.add('show', 'error');
            help.textContent = message || 'Error loading automations';
            help.classList.add('error');
            break;
        default:
            help.textContent = 'Choose which automation to trigger';
    }
}

function populateAutomationList(automations) {
    const select = document.getElementById('automationSelect');
    
    if (automations.length === 0) {
        select.innerHTML = '<option value="">No automations found</option>';
        select.disabled = true;
        setApiKeyState('success', 'API key valid');
        setAutomationState('error', 'No Stream Deck automations found');
        return;
    }
    
    // Build the full options list
    select.disabled = false;
    select.innerHTML = '<option value="">Select an automation</option>';
    automations.forEach(automation => {
        const option = document.createElement('option');
        option.value = automation.id;
        option.textContent = automation.name;
        select.appendChild(option);
    });
    
    setApiKeyState('success', 'API key valid');
    
    // Restore previously selected automation if it exists in the new list
    if (globalSettings.automationId) {
        const matchingAutomation = automations.find(auto => auto.id === globalSettings.automationId);
        if (matchingAutomation) {
            select.value = globalSettings.automationId;
            setAutomationState('success', 'Automation configured');
        } else {
            // Previously selected automation is no longer available
            setAutomationState('default', 'Previous automation no longer available');
            // Clear the invalid saved settings
            globalSettings.automationId = '';
            globalSettings.automationName = '';
        }
    } else {
        setAutomationState('default');
    }
}

function showError(errorMessage) {
    const select = document.getElementById('automationSelect');
    select.innerHTML = '<option value="">API Error</option>';
    select.disabled = true;
    setApiKeyState('error', errorMessage);
    setAutomationState('error', 'Cannot load automations');
}
    </script>

    <div style="position: fixed; bottom: 10px; left: 0; right: 0; text-align: center; padding: 10px;">
        <div style="border-top: 1px solid #333; padding-top: 10px; margin: 0 20px;">
            <a href="https://docs.eeko.app" target="_blank" style="color: #999; text-decoration: none; font-size: 11px;">
                Documentation
            </a>
            <span style="color: #555; margin: 0 8px;">|</span>
            <a href="https://docs.eeko.app/api" target="_blank" style="color: #999; text-decoration: none; font-size: 11px;">
                API Reference
            </a>
        </div>
    </div>
</body>
</html>